library;
import self as self;
import "dart:core" as core;

class None extends core::Object /*hasConstConstructor*/  {
  const constructor •() → self::None
    : super core::Object::•()
    ;
}
extension type Option<V extends core::Object? = dynamic>(core::Object? _value) {
  abstract extension-type-member representation-field get _value() → core::Object?;
  static field none = self::Option|none;
  get value = self::Option|get#value;
  constructor • = self::Option|constructor#;
  constructor tearoff • = self::Option|constructor#_#new#tearOff;
}
static const field self::Option<Never>% /* erasure=core::Object?, declared=! */ Option|none = const self::None::•() as self::Option<Never>% /* erasure=core::Object?, declared=! */;
static extension-type-member method Option|constructor#<V extends core::Object? = dynamic>(core::Object? _value) → self::Option<self::Option|constructor#::V%>% /* erasure=core::Object?, declared=! */ {
  lowered final self::Option<self::Option|constructor#::V%>% /* erasure=core::Object?, declared=! */ #this = _value;
  return #this;
}
static extension-type-member method Option|constructor#_#new#tearOff<V extends core::Object? = dynamic>(core::Object? _value) → self::Option<self::Option|constructor#_#new#tearOff::V%>% /* erasure=core::Object?, declared=! */
  return self::Option|constructor#<self::Option|constructor#_#new#tearOff::V%>(_value);
static extension-type-member method Option|get#value<V extends core::Object? = dynamic>(lowered final self::Option<self::Option|get#value::V%>% /* erasure=core::Object?, declared=! */ #this) → self::Option|get#value::V%
  ;


Extra constant evaluation status:
Evaluated: AsExpression @ org-dartlang-testcase:///issue52542.dart:6:50 -> InstanceConstant(const None{})
Extra constant evaluation: evaluated: 5, effectively constant: 1
