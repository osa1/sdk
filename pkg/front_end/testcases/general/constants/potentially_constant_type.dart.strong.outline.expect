library;
//
// Problems in library:
//
// pkg/front_end/testcases/general/constants/potentially_constant_type.dart:36:21: Error: Constant expression expected.
// Try inserting 'const'.
//         field5 = <T>[],
//                     ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type.dart:36:19: Error: Type variables can't be used as constants.
//         field5 = <T>[],
//                   ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type.dart:37:21: Error: Constant expression expected.
// Try inserting 'const'.
//         field6 = <T>{},
//                     ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type.dart:37:19: Error: Type variables can't be used as constants.
//         field6 = <T>{},
//                   ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type.dart:38:24: Error: Constant expression expected.
// Try inserting 'const'.
//         field7 = <T, T>{},
//                        ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type.dart:38:19: Error: Type variables can't be used as constants.
//         field7 = <T, T>{},
//                   ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type.dart:38:22: Error: Type variables can't be used as constants.
//         field7 = <T, T>{},
//                      ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type.dart:46:29: Error: Constant expression expected.
// Try inserting 'const'.
//         field15 = <Class<T>>[],
//                             ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type.dart:46:26: Error: Type variables can't be used as constants.
//         field15 = <Class<T>>[],
//                          ^
//
import self as self;
import "dart:core" as core;
import "dart:collection" as col;

import "org-dartlang-testcase:///potentially_constant_type_lib1.dart";

typedef F<X extends core::Object? = dynamic, unrelated Y extends core::Object? = dynamic> = self::Class<X%>;
typedef G<unrelated X extends core::Object? = dynamic> = self::Class<core::int>;
class Class<T extends core::Object? = dynamic> extends core::Object /*hasConstConstructor*/  {
  final field dynamic field1;
  final field dynamic field2;
  final field dynamic field3;
  final field dynamic field4;
  final field dynamic field5;
  final field dynamic field6;
  final field dynamic field7;
  final field dynamic field8;
  final field dynamic field9;
  final field dynamic field10;
  final field dynamic field11;
  final field dynamic field12;
  final field dynamic field13;
  final field dynamic field14;
  final field dynamic field15;
  final field dynamic field16;
  const constructor •(dynamic o) → self::Class<self::Class::T%>
    : self::Class::field1 = self::Class::T%, self::Class::field2 = self::Class<self::Class::T%>, self::Class::field3 = self::id<self::Class::T%>, self::Class::field4 = self::id<self::Class::T%>, self::Class::field5 = <invalid-type>[], self::Class::field6 = block {
      final core::Set<invalid-type> #t1 = col::LinkedHashSet::•<invalid-type>();
    } =>#t1, self::Class::field7 = <invalid-type, invalid-type>{}, self::Class::field8 = o is self::Class::T%, self::Class::field9 = o is self::Class<self::Class::T%>, self::Class::field10 = o as self::Class::T%, self::Class::field11 = o{self::Class::T%} as self::Class<self::Class::T%>, self::Class::field12 = self::Class::•<self::Class::T%>, self::Class::field13 = self::Class::•<self::Class::T%>, self::Class::field14 = self::id<self::Class<self::Class::T%>>, self::Class::field15 = <self::Class<invalid-type>>[], self::Class::field16 = self::Class::•<core::int>, super core::Object::•()
    ;
  method method() → void
    ;
}
static method id<T extends core::Object? = dynamic>(self::id::T% t) → self::id::T%
  ;
static method main() → dynamic
  ;
static method _#F#new#tearOff<X extends core::Object? = dynamic, unrelated Y extends core::Object? = dynamic>(dynamic o) → self::Class<self::_#F#new#tearOff::X%>
  return new self::Class::•<self::_#F#new#tearOff::X%>(o);
static method _#G#new#tearOff<unrelated X extends core::Object? = dynamic>(dynamic o) → self::Class<core::int>
  return new self::Class::•<core::int>(o);

library;
//
// Problems in library:
//
// pkg/front_end/testcases/general/constants/potentially_constant_type_lib1.dart:23:18: Error: Type variables can't be used as constants.
//       : field1 = T,
//                  ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type_lib1.dart:24:21: Error: Constant expression expected.
// Try inserting 'const'.
//         field5 = <T>[],
//                     ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type_lib1.dart:24:19: Error: Type variables can't be used as constants.
//         field5 = <T>[],
//                   ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type_lib1.dart:25:21: Error: Constant expression expected.
// Try inserting 'const'.
//         field6 = <T>{},
//                     ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type_lib1.dart:25:19: Error: Type variables can't be used as constants.
//         field6 = <T>{},
//                   ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type_lib1.dart:26:24: Error: Constant expression expected.
// Try inserting 'const'.
//         field7 = <T, T>{},
//                        ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type_lib1.dart:26:19: Error: Type variables can't be used as constants.
//         field7 = <T, T>{},
//                   ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type_lib1.dart:26:22: Error: Type variables can't be used as constants.
//         field7 = <T, T>{},
//                      ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type_lib1.dart:31:29: Error: Constant expression expected.
// Try inserting 'const'.
//         field15 = <Class<T>>[];
//                             ^
//
// pkg/front_end/testcases/general/constants/potentially_constant_type_lib1.dart:31:26: Error: Type variables can't be used as constants.
//         field15 = <Class<T>>[];
//                          ^
//
import self as self2;
import "dart:core" as core;
import "dart:collection" as col;

class Class<T extends core::Object? = dynamic> extends core::Object /*hasConstConstructor*/  {
  final field dynamic field1;
  final field dynamic field5;
  final field dynamic field6;
  final field dynamic field7;
  final field dynamic field8;
  final field dynamic field9;
  final field dynamic field10;
  final field dynamic field11;
  final field dynamic field15;
  const constructor •(dynamic o) → self2::Class<self2::Class::T%>
    : self2::Class::field1 = invalid-type, self2::Class::field5 = <invalid-type>[], self2::Class::field6 = block {
      final core::Set<invalid-type> #t2 = col::LinkedHashSet::•<invalid-type>();
    } =>#t2, self2::Class::field7 = <invalid-type, invalid-type>{}, self2::Class::field8 = o is self2::Class::T%, self2::Class::field9 = o is self2::Class<self2::Class::T%>, self2::Class::field10 = o as self2::Class::T%, self2::Class::field11 = o{self2::Class::T%} as self2::Class<self2::Class::T%>, self2::Class::field15 = <self2::Class<invalid-type>>[], super core::Object::•()
    ;
  method method() → void
    ;
}
static method id<T extends core::Object? = dynamic>(self2::id::T% t) → self2::id::T%
  ;
static method main() → dynamic
  ;


Extra constant evaluation status:
Evaluated: StaticTearOff @ org-dartlang-testcase:///potentially_constant_type.dart:34:18 -> StaticTearOffConstant(id)
Evaluated: StaticTearOff @ org-dartlang-testcase:///potentially_constant_type.dart:35:19 -> StaticTearOffConstant(id)
Evaluated: ConstructorTearOff @ org-dartlang-testcase:///potentially_constant_type.dart:43:19 -> ConstructorTearOffConstant(Class.)
Evaluated: ConstructorTearOff @ org-dartlang-testcase:///potentially_constant_type.dart:44:19 -> ConstructorTearOffConstant(Class.)
Evaluated: StaticTearOff @ org-dartlang-testcase:///potentially_constant_type.dart:45:19 -> StaticTearOffConstant(id)
Evaluated: Instantiation @ org-dartlang-testcase:///potentially_constant_type.dart:47:19 -> InstantiationConstant(Class.<int>)
Evaluated: TypeLiteral @ org-dartlang-testcase:///potentially_constant_type_lib1.dart:23:18 -> TypeLiteralConstant(<invalid>)
Extra constant evaluation: evaluated: 46, effectively constant: 7
