library;
import self as self;
import "dart:core" as core;

typedef Foo<unrelated T extends self::V<core::num, core::Object> /* = core::num */> = (self::V<core::int, core::int> /* = core::int */) → self::V<core::int, core::int> /* = core::int */;
typedef IntNumV = self::V<core::int, core::num> /* = core::int */;
class C<T extends self::V<core::num, core::Object> /* = core::num */> extends core::Object {
  field (self::V<core::int, core::int> /* = core::int */) → self::V<core::int, core::int> /* = core::int */ f;
  synthetic constructor •() → self::C<self::C::T>
    ;
}
extension type V<X1 extends core::num, X2 extends core::Object>(X1 id) {
  constructor • = self::V|;
  tearoff • = self::V|_#new#tearOff;
}
static inline-class-member method V|<X1 extends core::num, X2 extends core::Object>(self::V|::X1 id) → self::V<self::V|::X1, self::V|::X2> /* = self::V|::X1 */
  ;
static inline-class-member method V|_#new#tearOff<X1 extends core::num, X2 extends core::Object>(self::V|_#new#tearOff::X1 id) → self::V<self::V|_#new#tearOff::X1, self::V|_#new#tearOff::X2> /* = self::V|_#new#tearOff::X1 */
  return self::V|<self::V|_#new#tearOff::X1, self::V|_#new#tearOff::X2>(id);
static method foo<T extends self::V<core::num, core::Object> /* = core::num */>(self::foo::T t) → self::V<core::int, core::int> /* = core::int */
  ;
static method main() → dynamic
  ;
static method expect(dynamic expected, dynamic actual) → dynamic
  ;
